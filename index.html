<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="BookReader">
<meta name="theme-color" content="#1a1a2e">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêõ</text></svg>">
<title>‰Ωë‰ΩëÁöÑÂ∞è‰π¶Ëô´</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --pink: #f472b6;
    --pink-light: #f9a8d4;
    --pink-hot: #ec4899;
    --yellow: #fbbf24;
    --orange: #fb923c;
    --purple: #a78bfa;
    --blue: #60a5fa;
    --green: #4ade80;
    --bg-warm: #1e1026;
    --bg-card: #2e1f3d;
    --radius: 20px;
  }

  body {
    font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg-warm);
    color: #fff;
    height: 100dvh;
    overflow: hidden;
    touch-action: manipulation;
  }

  /* Camera viewfinder */
  #camera-container {
    position: relative;
    width: 100%;
    height: 100dvh;
  }

  #video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 0;
  }

  #canvas { display: none; }

  /* Decorative frame around camera */
  #camera-frame {
    position: absolute;
    inset: 12px;
    border: 3px dashed rgba(255,255,255,0.25);
    border-radius: 24px;
    pointer-events: none;
    z-index: 2;
  }

  /* Top bar with mascot and name */
  #top-bar {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding: 12px 16px 16px;
    background: linear-gradient(to bottom, rgba(30,16,38,0.9) 0%, transparent 100%);
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  #mascot {
    font-size: 36px;
    animation: wiggle 2s ease-in-out infinite;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }

  @keyframes wiggle {
    0%, 100% { transform: rotate(-5deg); }
    50% { transform: rotate(5deg); }
  }

  #app-title {
    display: flex;
    flex-direction: column;
    line-height: 1.1;
  }

  #app-title .cn {
    font-size: 20px;
    font-weight: 800;
    background: linear-gradient(135deg, var(--pink), var(--purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  #app-title .en {
    font-size: 11px;
    font-weight: 600;
    color: rgba(255,255,255,0.6);
    letter-spacing: 0.5px;
  }

  /* Capture button */
  #capture-btn {
    position: absolute;
    bottom: 36px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 5px solid #fff;
    background: linear-gradient(135deg, var(--pink), var(--purple));
    cursor: pointer;
    z-index: 10;
    transition: transform 0.15s, box-shadow 0.15s;
    box-shadow: 0 4px 20px rgba(244,114,182,0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
  }
  #capture-btn::after {
    content: 'üìñ';
    font-size: 32px;
  }
  #capture-btn:active {
    transform: translateX(-50%) scale(0.88);
    box-shadow: 0 2px 10px rgba(244,114,182,0.3);
  }

  /* Pulsing hint when idle */
  #capture-btn::before {
    content: '';
    position: absolute;
    inset: -8px;
    border-radius: 50%;
    border: 3px solid var(--pink);
    animation: pulse-ring 2s ease-out infinite;
    opacity: 0;
  }

  @keyframes pulse-ring {
    0% { transform: scale(0.9); opacity: 0.6; }
    100% { transform: scale(1.3); opacity: 0; }
  }

  /* Bottom hint text */
  #hint {
    position: absolute;
    bottom: 126px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    font-weight: 700;
    color: rgba(255,255,255,0.7);
    z-index: 10;
    text-shadow: 0 1px 4px rgba(0,0,0,0.5);
    white-space: nowrap;
  }

  /* Auto mode toggle */
  #auto-toggle {
    position: absolute;
    bottom: 36px;
    left: 24px;
    padding: 10px 16px;
    border-radius: 20px;
    border: 2px solid rgba(255,255,255,0.3);
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(8px);
    color: rgba(255,255,255,0.6);
    font-size: 12px;
    font-weight: 800;
    font-family: inherit;
    letter-spacing: 1px;
    cursor: pointer;
    z-index: 10;
    transition: all 0.2s;
  }
  #auto-toggle.active {
    background: var(--pink);
    border-color: var(--pink);
    color: #fff;
    box-shadow: 0 2px 12px rgba(244,114,182,0.4);
  }
  #auto-toggle:active { transform: scale(0.93); }

  /* Settings gear */
  #settings-btn {
    position: absolute;
    top: 16px;
    right: 16px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: rgba(255,255,255,0.15);
    backdrop-filter: blur(8px);
    color: #fff;
    font-size: 20px;
    cursor: pointer;
    z-index: 11;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s;
  }
  #settings-btn:active { transform: scale(0.9); }

  /* Status overlay */
  #status {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--bg-card);
    padding: 24px 36px;
    border-radius: var(--radius);
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    z-index: 10;
    display: none;
    max-width: 85%;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    border: 2px solid rgba(255,255,255,0.1);
  }
  #status.visible {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }
  #status .spinner {
    width: 36px;
    height: 36px;
    border: 4px solid rgba(255,255,255,0.2);
    border-top-color: var(--pink);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Reading animation */
  #reading-indicator {
    position: absolute;
    bottom: 36px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    align-items: center;
    gap: 12px;
    background: var(--bg-card);
    padding: 16px 28px;
    border-radius: 40px;
    z-index: 10;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    border: 2px solid rgba(255,255,255,0.1);
  }
  #reading-indicator.visible { display: flex; }

  .sound-bars {
    display: flex;
    align-items: center;
    gap: 3px;
    height: 24px;
  }
  .sound-bars span {
    width: 4px;
    border-radius: 2px;
    background: var(--pink);
    animation: bar-bounce 1s ease-in-out infinite;
  }
  .sound-bars span:nth-child(1) { height: 8px; animation-delay: 0s; }
  .sound-bars span:nth-child(2) { height: 16px; animation-delay: 0.15s; }
  .sound-bars span:nth-child(3) { height: 24px; animation-delay: 0.3s; }
  .sound-bars span:nth-child(4) { height: 16px; animation-delay: 0.45s; }
  .sound-bars span:nth-child(5) { height: 8px; animation-delay: 0.6s; }

  @keyframes bar-bounce {
    0%, 100% { transform: scaleY(0.4); }
    50% { transform: scaleY(1); }
  }

  #reading-indicator .label {
    font-size: 15px;
    font-weight: 700;
    color: rgba(255,255,255,0.9);
  }

  #stop-btn {
    width: 40px;
    height: 40px;
    border-radius: 12px;
    border: none;
    background: rgba(255,77,77,0.9);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.1s;
  }
  #stop-btn::after {
    content: '';
    width: 16px;
    height: 16px;
    border-radius: 3px;
    background: #fff;
  }
  #stop-btn:active { transform: scale(0.9); }

  /* Narration text overlay */
  #narration-overlay {
    position: absolute;
    bottom: 100px;
    left: 12px;
    right: 12px;
    max-height: 50vh;
    overflow-y: auto;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(12px);
    border-radius: 20px;
    padding: 20px 20px 16px;
    z-index: 10;
    display: none;
    border: 2px solid rgba(255,255,255,0.1);
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    -webkit-overflow-scrolling: touch;
  }
  #narration-overlay.visible { display: block; }

  .narration-line {
    font-size: 22px;
    font-weight: 700;
    line-height: 1.8;
    padding: 2px 0;
  }
  .narration-word {
    display: inline;
    padding: 2px 1px;
    border-radius: 4px;
    color: rgba(255,255,255,0.25);
    transition: color 0.2s, background 0.2s;
  }
  .narration-word.active {
    color: #fff;
    background: rgba(244,114,182,0.35);
    border-radius: 6px;
    padding: 2px 4px;
  }
  .narration-word.read {
    color: rgba(255,255,255,0.6);
    background: none;
  }

  /* Repeat button */
  #repeat-btn {
    position: absolute;
    bottom: 36px;
    right: 24px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    border: 3px solid rgba(255,255,255,0.3);
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(8px);
    color: #fff;
    font-size: 24px;
    cursor: pointer;
    z-index: 10;
    display: none;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
  }
  #repeat-btn.visible {
    display: flex;
  }
  #repeat-btn:active { transform: scale(0.9); }
  #repeat-btn.active {
    background: var(--pink);
    border-color: var(--pink);
    box-shadow: 0 2px 12px rgba(244,114,182,0.4);
  }

  /* Play Book button */
  #play-book-btn {
    position: absolute;
    top: 16px;
    right: 70px;
    height: 56px;
    padding: 0 20px;
    border-radius: 28px;
    border: 3px solid rgba(255,255,255,0.3);
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(8px);
    color: #fff;
    font-size: 13px;
    font-weight: 800;
    font-family: inherit;
    cursor: pointer;
    z-index: 10;
    display: none;
    align-items: center;
    gap: 8px;
    transition: all 0.2s;
    letter-spacing: 0.5px;
  }
  #play-book-btn.visible { display: flex; }
  #play-book-btn:active { transform: scale(0.93); }
  #play-book-btn .icon { font-size: 20px; }
  #play-book-btn .page-count {
    background: var(--pink);
    color: #fff;
    border-radius: 10px;
    padding: 2px 8px;
    font-size: 12px;
    font-weight: 800;
  }

  /* Page counter badge on capture button */
  #page-badge {
    position: absolute;
    bottom: 112px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--pink);
    color: #fff;
    font-size: 12px;
    font-weight: 800;
    padding: 4px 12px;
    border-radius: 12px;
    z-index: 10;
    display: none;
    box-shadow: 0 2px 8px rgba(244,114,182,0.3);
  }
  #page-badge.visible { display: block; }

  /* Captured image display */
  #captured-img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: contain;
    background: #000;
    z-index: 3;
    display: none;
    border-radius: 12px;
  }
  #captured-img.visible { display: block; }

  /* Word highlight overlays */
  #word-overlays {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 4;
    pointer-events: none;
    display: none;
  }
  #word-overlays.visible { display: block; }

  .text-highlight {
    position: absolute;
    border-radius: 6px;
    pointer-events: none;
    background: rgba(244, 114, 182, 0.0);
    transition: background 0.4s, box-shadow 0.4s;
  }
  .text-highlight.active {
    background: rgba(244, 114, 182, 0.35);
    box-shadow: 0 0 20px rgba(244, 114, 182, 0.5), inset 0 0 8px rgba(244, 114, 182, 0.15);
  }
  .text-highlight.read {
    background: rgba(244, 114, 182, 0.12);
  }

  /* Flash effect on capture */
  #flash {
    position: absolute;
    inset: 0;
    background: var(--pink-light);
    opacity: 0;
    z-index: 5;
    pointer-events: none;
    transition: opacity 0.15s;
  }
  #flash.active { opacity: 0.5; }

  /* Settings panel */
  #settings-panel {
    position: absolute;
    inset: 0;
    background: var(--bg-warm);
    z-index: 20;
    padding: 24px;
    padding-top: 60px;
    display: none;
    overflow-y: auto;
  }
  #settings-panel.visible { display: block; }

  #settings-panel h2 {
    font-size: 24px;
    font-weight: 800;
    margin-bottom: 8px;
    background: linear-gradient(135deg, var(--pink), var(--purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  #settings-panel .subtitle {
    font-size: 13px;
    color: rgba(255,255,255,0.5);
    margin-bottom: 28px;
  }

  .setting-group {
    margin-bottom: 24px;
    background: var(--bg-card);
    border-radius: 16px;
    padding: 16px;
  }

  .setting-group label {
    display: block;
    font-size: 13px;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
    margin-bottom: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .setting-group select,
  .setting-group input[type="password"],
  .setting-group input[type="text"] {
    width: 100%;
    padding: 12px 14px;
    border-radius: 12px;
    border: 2px solid rgba(255,255,255,0.1);
    background: rgba(0,0,0,0.3);
    color: #fff;
    font-size: 16px;
    font-family: inherit;
    -webkit-appearance: none;
    transition: border-color 0.2s;
  }
  .setting-group select:focus,
  .setting-group input:focus {
    outline: none;
    border-color: var(--pink);
  }

  .setting-group input[type="range"] {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(255,255,255,0.15);
    -webkit-appearance: none;
    outline: none;
  }
  .setting-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--pink), var(--purple));
    border: 3px solid #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  .speed-labels {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    font-weight: 700;
    color: rgba(255,255,255,0.4);
    margin-top: 8px;
  }

  #close-settings {
    position: absolute;
    top: 16px;
    right: 16px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: rgba(255,255,255,0.1);
    color: #fff;
    font-size: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #save-api-key {
    width: 100%;
    padding: 16px;
    border-radius: 16px;
    border: none;
    background: linear-gradient(135deg, var(--pink), var(--purple));
    color: #fff;
    font-size: 17px;
    font-weight: 800;
    font-family: inherit;
    cursor: pointer;
    margin-top: 8px;
    box-shadow: 0 4px 16px rgba(244,114,182,0.3);
    transition: transform 0.1s;
  }
  #save-api-key:active { transform: scale(0.97); }

  /* API key prompt overlay */
  #api-key-overlay {
    position: absolute;
    inset: 0;
    background: var(--bg-warm);
    z-index: 30;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 32px;
  }
  #api-key-overlay.hidden { display: none; }

  #api-key-overlay .mascot-big {
    font-size: 72px;
    margin-bottom: 16px;
    animation: wiggle 2s ease-in-out infinite;
  }

  #api-key-overlay h2 {
    font-size: 32px;
    font-weight: 800;
    background: linear-gradient(135deg, var(--pink), var(--pink-hot), var(--purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 4px;
  }
  #api-key-overlay .en-subtitle {
    font-size: 14px;
    font-weight: 600;
    color: rgba(255,255,255,0.5);
    margin-bottom: 32px;
  }
  #api-key-overlay p {
    color: rgba(255,255,255,0.6);
    margin-bottom: 24px;
    text-align: center;
    font-size: 14px;
    line-height: 1.5;
  }
  #api-key-overlay input {
    width: 100%;
    max-width: 400px;
    padding: 14px 16px;
    border-radius: 14px;
    border: 2px solid rgba(255,255,255,0.15);
    background: var(--bg-card);
    color: #fff;
    font-size: 16px;
    font-family: inherit;
    margin-bottom: 16px;
    transition: border-color 0.2s;
  }
  #api-key-overlay input:focus {
    outline: none;
    border-color: var(--pink);
  }
  #api-key-overlay button {
    width: 100%;
    max-width: 400px;
    padding: 16px;
    border-radius: 16px;
    border: none;
    background: linear-gradient(135deg, var(--pink), var(--purple));
    color: #fff;
    font-size: 18px;
    font-weight: 800;
    font-family: inherit;
    cursor: pointer;
    box-shadow: 0 4px 20px rgba(244,114,182,0.3);
    transition: transform 0.1s;
  }
  #api-key-overlay button:active { transform: scale(0.97); }

  /* Floating decorative dots */
  .dot {
    position: absolute;
    border-radius: 50%;
    pointer-events: none;
    opacity: 0.15;
  }
  .dot-1 { width: 120px; height: 120px; background: var(--pink); top: -30px; left: -30px; }
  .dot-2 { width: 80px; height: 80px; background: var(--purple); bottom: 60px; right: -20px; }
  .dot-3 { width: 60px; height: 60px; background: var(--pink-light); top: 40%; left: -20px; }

  /* ===== Landscape layout ===== */
  @media (orientation: landscape) {
    /* Move capture button to the right side */
    #capture-btn {
      bottom: 50%;
      left: auto;
      right: 20px;
      transform: translateY(50%);
      width: 64px;
      height: 64px;
    }
    #capture-btn::after { font-size: 26px; }
    #capture-btn:active {
      transform: translateY(50%) scale(0.88);
    }
    #capture-btn::before {
      inset: -6px;
    }

    /* Hint text moves to right side above button */
    #hint {
      bottom: auto;
      top: 50%;
      left: auto;
      right: 96px;
      transform: translateY(-50%);
      writing-mode: horizontal-tb;
    }

    /* Auto toggle moves to bottom-left, smaller */
    #auto-toggle {
      bottom: 16px;
      left: 16px;
    }

    /* Repeat button moves to right, below capture */
    #repeat-btn {
      bottom: calc(50% - 80px);
      right: 24px;
      width: 48px;
      height: 48px;
      font-size: 20px;
    }

    /* Settings gear stays top-right but tighter */
    #settings-btn {
      top: 8px;
      right: 8px;
    }

    /* Top bar more compact */
    #top-bar {
      padding: 6px 12px 8px;
    }
    #mascot { font-size: 28px; }
    #app-title .cn { font-size: 16px; }
    #app-title .en { font-size: 10px; }

    /* Camera frame tighter */
    #camera-frame { inset: 8px; }

    /* Reading indicator moves to right side */
    #reading-indicator {
      bottom: auto;
      top: 50%;
      left: auto;
      right: 12px;
      transform: translateY(-50%);
      flex-direction: column;
      padding: 16px 14px;
      border-radius: 24px;
    }

    /* Narration overlay takes left portion of screen */
    #narration-overlay {
      bottom: 8px;
      top: 56px;
      left: 8px;
      right: 40%;
      max-height: none;
      border-radius: 16px;
      padding: 16px;
    }
    .narration-line {
      font-size: 18px;
      line-height: 1.6;
    }

    /* Play book button in landscape */
    #play-book-btn {
      top: 8px;
      right: 62px;
      height: 44px;
      font-size: 11px;
    }
    #page-badge {
      bottom: auto;
      top: 50%;
      left: auto;
      right: 96px;
      transform: translateY(calc(-50% - 40px));
    }

    /* Status overlay */
    #status {
      max-width: 60%;
    }
  }
</style>
</head>
<body>

<div id="camera-container">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
  <img id="captured-img" alt="">
  <div id="word-overlays"></div>
  <div id="flash"></div>
  <div id="camera-frame"></div>

  <!-- Top bar -->
  <div id="top-bar">
    <div id="mascot">üêõ</div>
    <div id="app-title">
      <span class="cn">‰Ωë‰ΩëÁöÑÂ∞è‰π¶Ëô´</span>
      <span class="en">Hunter's Little Bookworm</span>
    </div>
  </div>

  <div id="hint">Point at a book page, then tap!</div>

  <button id="capture-btn" title="Read this page"></button>

  <!-- Auto mode toggle -->
  <button id="auto-toggle" title="Toggle auto page detection">AUTO</button>

  <!-- Reading indicator (replaces old stop button) -->
  <div id="reading-indicator">
    <div class="sound-bars">
      <span></span><span></span><span></span><span></span><span></span>
    </div>
    <span class="label">Reading...</span>
    <button id="stop-btn" title="Stop"></button>
  </div>

  <!-- Narration text overlay -->
  <div id="narration-overlay"></div>

  <!-- Page counter badge -->
  <div id="page-badge"></div>

  <!-- Play full book button -->
  <button id="play-book-btn" title="Play full book">
    <span class="icon">üìö</span>
    <span>PLAY BOOK</span>
    <span class="page-count" id="book-page-count">0</span>
  </button>

  <!-- Repeat last page button -->
  <button id="repeat-btn" title="Repeat">üîÅ</button>

  <button id="settings-btn">&#9881;</button>

  <div id="status"></div>

  <!-- Settings panel -->
  <div id="settings-panel">
    <button id="close-settings">&times;</button>
    <h2>Settings</h2>
    <div class="subtitle">Parental controls</div>

    <div class="setting-group">
      <label>OpenAI API Key</label>
      <input type="password" id="settings-api-key" placeholder="sk-...">
    </div>

    <div class="setting-group">
      <label>Reading Speed</label>
      <input type="range" id="speed" min="0.5" max="1.5" step="0.1" value="0.9">
      <div class="speed-labels">
        <span>Learning</span>
        <span>Story</span>
        <span>Fluent</span>
      </div>
    </div>

    <div class="setting-group">
      <label>Response Language</label>
      <select id="response-lang">
        <option value="Chinese">‰∏≠Êñá (Chinese)</option>
        <option value="English">English</option>
        <option value="match">Match book language</option>
      </select>
    </div>

    <div class="setting-group">
      <label>TTS Provider</label>
      <select id="tts-provider">
        <option value="openai">OpenAI TTS</option>
        <option value="elevenlabs">ElevenLabs (more expressive)</option>
      </select>
    </div>

    <div class="setting-group">
      <label>Voice</label>
      <select id="voice">
        <option value="fable">Fable (expressive)</option>
        <option value="nova">Nova (warm)</option>
        <option value="shimmer">Shimmer (gentle)</option>
        <option value="echo">Echo (calm)</option>
        <option value="alloy">Alloy (neutral)</option>
        <option value="onyx">Onyx (deep)</option>
      </select>
    </div>

    <div class="setting-group" id="elevenlabs-settings" style="display:none;">
      <label>ElevenLabs API Key</label>
      <input type="password" id="elevenlabs-api-key" placeholder="sk_...">
      <label style="margin-top:12px;">ElevenLabs Voice</label>
      <select id="elevenlabs-voice">
        <option value="pNInz6obpgDQGcFmaJgB">Adam (narration)</option>
        <option value="ErXwobaYiN019PkySvjV">Antoni (warm)</option>
        <option value="EXAVITQu4vr4xnSDxMaL">Bella (soft)</option>
        <option value="onwK4e9ZLuTAKqWW03F9">Daniel (deep)</option>
        <option value="MF3mGyEYCl7XYWbV9V6O">Emily (storytelling)</option>
        <option value="TX3LPaxmHKxFdv7VOQHJ">Liam (friendly)</option>
        <option value="pFZP5JQG7iQjIQuC4Bku">Lily (gentle)</option>
      </select>
      <label style="margin-top:12px;">Expressiveness</label>
      <input type="range" id="elevenlabs-stability" min="0" max="1" step="0.05" value="0.3">
      <div class="speed-labels">
        <span>More expressive</span>
        <span>More stable</span>
      </div>
    </div>

    <button id="save-api-key">Save Settings</button>
  </div>

  <!-- API key first-run prompt -->
  <div id="api-key-overlay">
    <div class="dot dot-1"></div>
    <div class="dot dot-2"></div>
    <div class="dot dot-3"></div>
    <div class="mascot-big">üêõ</div>
    <h2>‰Ωë‰ΩëÁöÑÂ∞è‰π¶Ëô´</h2>
    <div class="en-subtitle">Hunter's Little Bookworm</div>
    <p>Your child's reading companion!<br>Enter your OpenAI API key to get started.</p>
    <input type="password" id="initial-api-key" placeholder="sk-..." autocomplete="off">
    <button id="submit-api-key">Start Reading!</button>
  </div>
</div>

<script>
const $ = (sel) => document.querySelector(sel);

// --- State ---
let apiKey = localStorage.getItem('openai_api_key') || '';
let currentAudio = null;
let isProcessing = false;
let lastNarrationText = null;
let lastAudioBuffer = null;
let highlightTimers = [];
let bookPages = []; // Array of {text, audioBuffer} for full book playback
let isPlayingBook = false;
let bookPlaybackIndex = 0;
let lastImageDataUrl = null;
let lastTextBlocks = null;

// Auto page detection state
let autoMode = false;
let autoDetectInterval = null;
let lastFrameData = null;
const DIFF_THRESHOLD = 6; // % of pixels that must change to trigger
const CHECK_INTERVAL = 600; // ms between checks
const COOLDOWN_AFTER_READ = 2000; // ms to wait after reading before detecting again
let cooldownUntil = 0;

// Pre-create AudioContext to unlock audio on iOS Safari
let audioCtx = null;
function ensureAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

// --- Elements ---
const video = $('#video');
const canvas = $('#canvas');
const ctx = canvas.getContext('2d');
const captureBtn = $('#capture-btn');
const stopBtn = $('#stop-btn');
const statusEl = $('#status');
const flashEl = $('#flash');
const hintEl = $('#hint');
const readingIndicator = $('#reading-indicator');
const settingsPanel = $('#settings-panel');
const apiKeyOverlay = $('#api-key-overlay');
const narrationOverlay = $('#narration-overlay');
const repeatBtn = $('#repeat-btn');
const playBookBtn = $('#play-book-btn');
const bookPageCount = $('#book-page-count');
const pageBadge = $('#page-badge');
const capturedImg = $('#captured-img');
const wordOverlays = $('#word-overlays');

// --- Init ---
function init() {
  // Load saved settings
  $('#speed').value = localStorage.getItem('speed') || '0.9';
  $('#response-lang').value = localStorage.getItem('response_lang') || 'Chinese';
  $('#voice').value = localStorage.getItem('voice') || 'fable';
  $('#tts-provider').value = localStorage.getItem('tts_provider') || 'openai';
  $('#elevenlabs-api-key').value = localStorage.getItem('elevenlabs_api_key') || '';
  $('#elevenlabs-voice').value = localStorage.getItem('elevenlabs_voice') || 'pNInz6obpgDQGcFmaJgB';
  $('#elevenlabs-stability').value = localStorage.getItem('elevenlabs_stability') || '0.3';
  updateTTSProviderUI();

  if (apiKey) {
    apiKeyOverlay.classList.add('hidden');
    startCamera();
  }
}

// --- Camera ---
async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
      audio: false
    });
    video.srcObject = stream;
    greetHunter();
  } catch (err) {
    showStatus('Camera access denied. Please allow camera access and reload.');
  }
}

// --- Greeting ---
async function greetHunter() {
  ensureAudioContext();
  const lang = localStorage.getItem('response_lang') || 'Chinese';
  const greeting = lang === 'Chinese'
    ? 'Hi Hunter! ‰ªäÂ§©ÊàëÊù•Áªô‰Ω†ËØª‰∏ÄÊú¨‰π¶ÔºåÊàë‰ª¨ÂºÄÂßãÂêßÔºÅ'
    : 'Hi Hunter! Today I\'m going to read you a book. Let\'s begin!';
  try {
    const provider = localStorage.getItem('tts_provider') || 'openai';
    let arrayBuffer;
    if (provider === 'elevenlabs') {
      arrayBuffer = await elevenLabsTTS(greeting);
    } else {
      arrayBuffer = await openaiTTS(greeting);
    }
    audioCtx.decodeAudioData(arrayBuffer, (audioBuffer) => {
      const source = audioCtx.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioCtx.destination);
      source.start(0);
    });
  } catch (e) {
    // Greeting is non-critical, fail silently
  }
}

// --- Capture ---
function captureFrame() {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0);
  return canvas.toDataURL('image/jpeg', 0.8);
}

function flashEffect() {
  flashEl.classList.add('active');
  setTimeout(() => flashEl.classList.remove('active'), 150);
}

// --- Status ---
function showStatus(msg) {
  statusEl.innerHTML = `<div class="spinner"></div><span>${msg}</span>`;
  statusEl.classList.add('visible');
}

function hideStatus() {
  statusEl.classList.remove('visible');
}

// --- UI State transitions ---
function showReadingUI() {
  captureBtn.style.display = 'none';
  hintEl.style.display = 'none';
  autoToggle.style.display = 'none';
  repeatBtn.classList.remove('visible');
  playBookBtn.classList.remove('visible');
  pageBadge.classList.remove('visible');
  readingIndicator.classList.add('visible');
  hideStatus();
}

function showIdleUI() {
  captureBtn.style.display = '';
  hintEl.style.display = '';
  autoToggle.style.display = '';
  readingIndicator.classList.remove('visible');
  narrationOverlay.classList.remove('visible');
  hideCapturedImage();
  clearHighlightTimers();
  // Show repeat button if we have a previous narration
  if (lastAudioBuffer) {
    repeatBtn.classList.add('visible');
  }
  // Show play book button if we have 2+ pages
  if (bookPages.length >= 2) {
    playBookBtn.classList.add('visible');
    bookPageCount.textContent = bookPages.length;
  }
  // Show page count badge
  if (bookPages.length > 0) {
    pageBadge.textContent = `${bookPages.length} page${bookPages.length > 1 ? 's' : ''} saved`;
    pageBadge.classList.add('visible');
  }
}

// --- Narration display ---
function showNarration(text, audioDuration) {
  const lines = text.split('\n').filter(l => l.trim());
  let wordIdx = 0;

  narrationOverlay.innerHTML = lines.map((line) => {
    // Split into words, preserving punctuation attached to words
    const words = line.match(/\S+/g) || [];
    const wordSpans = words.map(word => {
      const span = `<span class="narration-word" data-widx="${wordIdx}">${escapeHtml(word)}</span>`;
      wordIdx++;
      return span;
    }).join(' ');
    return `<div class="narration-line">${wordSpans}</div>`;
  }).join('');

  narrationOverlay.classList.add('visible');
  narrationOverlay.scrollTop = 0;

  // Collect all words for highlighting
  const allWords = [];
  lines.forEach(line => {
    const words = line.match(/\S+/g) || [];
    words.forEach(w => allWords.push(w));
  });

  startWordHighlighting(allWords, audioDuration);
}

function escapeHtml(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function startWordHighlighting(words, totalDuration) {
  clearHighlightTimers();
  // Estimate time per word based on character length
  const totalChars = words.reduce((sum, w) => sum + w.length, 0);
  let elapsed = 0;

  words.forEach((word, i) => {
    const wordDuration = (word.length / totalChars) * totalDuration * 1000;

    const timer = setTimeout(() => {
      // Mark previous word as read
      const prev = narrationOverlay.querySelector('.narration-word.active');
      if (prev) {
        prev.classList.remove('active');
        prev.classList.add('read');
      }
      const el = narrationOverlay.querySelector(`[data-widx="${i}"]`);
      if (el) {
        el.classList.add('active');
        // Auto-scroll to keep active word visible
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }, elapsed);

    highlightTimers.push(timer);
    elapsed += wordDuration;
  });

  // Mark last word as read when audio ends
  const endTimer = setTimeout(() => {
    const last = narrationOverlay.querySelector('.narration-word.active');
    if (last) {
      last.classList.remove('active');
      last.classList.add('read');
    }
  }, totalDuration * 1000);
  highlightTimers.push(endTimer);
}

function clearHighlightTimers() {
  highlightTimers.forEach(t => clearTimeout(t));
  highlightTimers = [];
}

// --- Captured image & highlights ---
function showCapturedImage(dataUrl, pageBounds) {
  if (pageBounds) {
    // Crop to page bounds using the capture canvas
    const srcW = canvas.width;
    const srcH = canvas.height;
    const sx = (pageBounds.left / 100) * srcW;
    const sy = (pageBounds.top / 100) * srcH;
    const sw = ((pageBounds.right - pageBounds.left) / 100) * srcW;
    const sh = ((pageBounds.bottom - pageBounds.top) / 100) * srcH;
    const cropCanvas = document.createElement('canvas');
    cropCanvas.width = sw;
    cropCanvas.height = sh;
    cropCanvas.getContext('2d').drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
    capturedImg.src = cropCanvas.toDataURL('image/jpeg', 0.9);
  } else {
    capturedImg.src = dataUrl;
  }
  capturedImg.classList.add('visible');
  $('#camera-frame').style.display = 'none';
  $('#top-bar').style.display = 'none';
}

function hideCapturedImage() {
  capturedImg.classList.remove('visible');
  wordOverlays.classList.remove('visible');
  wordOverlays.innerHTML = '';
  $('#camera-frame').style.display = '';
  $('#top-bar').style.display = '';
}

function getImageRenderBounds() {
  if (!capturedImg.naturalWidth || !capturedImg.naturalHeight) return null;
  const cW = capturedImg.clientWidth;
  const cH = capturedImg.clientHeight;
  const nW = capturedImg.naturalWidth;
  const nH = capturedImg.naturalHeight;
  const imgRatio = nW / nH;
  const cRatio = cW / cH;
  let rW, rH, oX, oY;
  if (imgRatio > cRatio) {
    rW = cW; rH = cW / imgRatio; oX = 0; oY = (cH - rH) / 2;
  } else {
    rH = cH; rW = cH * imgRatio; oX = (cW - rW) / 2; oY = 0;
  }
  return { rW, rH, oX, oY };
}

function createTextHighlights(textBlocks, duration) {
  wordOverlays.innerHTML = '';
  const bounds = getImageRenderBounds();
  if (!bounds || !textBlocks || textBlocks.length === 0) return;

  textBlocks.forEach((block, i) => {
    const el = document.createElement('div');
    el.className = 'text-highlight';
    el.dataset.idx = i;
    el.style.left = (bounds.oX + (block.left / 100) * bounds.rW) + 'px';
    el.style.top = (bounds.oY + (block.top / 100) * bounds.rH) + 'px';
    el.style.width = ((block.width / 100) * bounds.rW) + 'px';
    el.style.height = ((block.height / 100) * bounds.rH) + 'px';
    wordOverlays.appendChild(el);
  });

  wordOverlays.classList.add('visible');
  animateHighlights(textBlocks, duration);
}

function animateHighlights(textBlocks, duration) {
  clearHighlightTimers();
  if (!textBlocks || textBlocks.length === 0) return;

  const totalChars = textBlocks.reduce((sum, b) => sum + b.text.length, 0);
  let elapsed = 0;

  textBlocks.forEach((block, i) => {
    const blockDuration = (block.text.length / totalChars) * duration * 1000;
    const timer = setTimeout(() => {
      const prev = wordOverlays.querySelector('.text-highlight.active');
      if (prev) {
        prev.classList.remove('active');
        prev.classList.add('read');
      }
      const el = wordOverlays.querySelector(`[data-idx="${i}"]`);
      if (el) el.classList.add('active');
    }, elapsed);
    highlightTimers.push(timer);
    elapsed += blockDuration;
  });

  const endTimer = setTimeout(() => {
    const last = wordOverlays.querySelector('.text-highlight.active');
    if (last) {
      last.classList.remove('active');
      last.classList.add('read');
    }
  }, duration * 1000);
  highlightTimers.push(endTimer);
}

// --- Main flow ---
async function processPage() {
  if (isProcessing) return;
  isProcessing = true;

  // Unlock audio on user gesture (required by iOS Safari)
  ensureAudioContext();

  flashEffect();
  const imageData = captureFrame();
  const base64Image = imageData.replace(/^data:image\/jpeg;base64,/, '');

  // Show captured image immediately (uncropped)
  capturedImg.src = imageData;
  capturedImg.classList.add('visible');
  $('#camera-frame').style.display = 'none';
  $('#top-bar').style.display = 'none';
  captureBtn.style.display = 'none';
  hintEl.style.display = 'none';
  showStatus('Reading the page...');

  try {
    // Step 1: GPT-4o Vision ‚Äî read, narrate, and get word positions
    const result = await getNarration(base64Image);
    if (!result || !result.narration) throw new Error('Could not read the page');

    lastNarrationText = result.narration;
    lastTextBlocks = result.text_blocks || [];

    // Crop to page bounds if available
    if (result.page_bounds) {
      showCapturedImage(imageData, result.page_bounds);
    }
    // Save the displayed image URL for replay
    lastImageDataUrl = capturedImg.src;

    showStatus('Preparing to read aloud...');
    showReadingUI();

    // Step 2: TTS ‚Äî speak the narration
    await speakNarration(result.narration, lastTextBlocks);

  } catch (err) {
    console.error(err);
    showStatus(err.message || 'Something went wrong');
    setTimeout(hideStatus, 3000);
  } finally {
    isProcessing = false;
    showIdleUI();
    // Set cooldown so auto-detect doesn't immediately re-trigger
    cooldownUntil = Date.now() + COOLDOWN_AFTER_READ;
    // Reset the reference frame so auto-detect compares against the new page
    if (autoMode) {
      resetAutoReference();
    }
  }
}

// --- GPT-4o Vision API ---
async function getNarration(base64Image) {
  const responseLang = localStorage.getItem('response_lang') || 'Chinese';

  let langInstruction;
  if (responseLang === 'Chinese') {
    langInstruction = 'If the book is in Chinese, narrate in Chinese. If in English, read as written.';
  } else if (responseLang === 'English') {
    langInstruction = 'If the book is in English, narrate in English. If Chinese, read in Chinese.';
  } else {
    langInstruction = 'Read the text in whatever language it is written in.';
  }

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model: 'gpt-4o',
      max_tokens: 4096,
      response_format: { type: 'json_object' },
      messages: [
        {
          role: 'system',
          content: `You are the world's most DRAMATIC children's book storyteller reading to Hunter, a 3-year-old. Return a JSON object with this EXACT structure:

{
  "narration": "Your dramatic reading here...",
  "page_bounds": {"top": 5, "left": 3, "bottom": 95, "right": 97},
  "text_blocks": [
    {"text": "Once upon a time", "top": 20, "left": 10, "width": 80, "height": 8}
  ]
}

FIELDS:
- "narration": Your theatrical, expressive reading of ALL text on the page. This goes to text-to-speech so make it ALIVE!
- "page_bounds": Where the actual book page is in the photo ‚Äî {top, left, bottom, right} as percentages (0-100) of the FULL IMAGE. This crops out the table/background around the book.
- "text_blocks": Every visible text region on the page, in reading order. Coordinates (top, left, width, height) are percentages (0-100) RELATIVE TO THE PAGE BOUNDS (not the full photo). Top-left corner of the page = 0,0.

NARRATION RULES ‚Äî You are PERFORMING, not just reading!
1. Read EVERY SINGLE WORD ‚Äî headers, body, speech bubbles, captions. Never skip!
2. Do NOT describe illustrations or add words not in the book.
3. For TWO-PAGE SPREADS, read LEFT page first, then RIGHT.
4. NEVER let the drama fade ‚Äî every sentence at MAXIMUM theatrical energy!
5. Format for TTS: "..." for suspense, "!" for excitement, CAPITALIZE for emphasis, stretch words like "huuuuge" and "sloooowly", "‚Äî" for dramatic pauses.
6. Add reactions: "Ohhh!", "Wooow!", "Oh noooo!" where the text calls for them.
7. Each sentence on its own line in the narration.
8. Whispered parts: lowercase with spaces: "and   then...   very   quietly..."

TEXT_BLOCKS RULES:
- Include ALL visible text ‚Äî titles, body text, labels, speech bubbles, page numbers
- Each block = one line or logical text group
- Be PRECISE with bounding boxes ‚Äî they will be drawn as highlights on the image
- Coordinates are relative to the PAGE area (after cropping to page_bounds)

${langInstruction}`
        },
        {
          role: 'user',
          content: [
            {
              type: 'image_url',
              image_url: { url: `data:image/jpeg;base64,${base64Image}`, detail: 'high' }
            },
            {
              type: 'text',
              text: 'Read this book page with maximum drama! Return JSON with narration, page_bounds, and text_blocks.'
            }
          ]
        }
      ]
    })
  });

  if (!response.ok) {
    const err = await response.json().catch(() => ({}));
    throw new Error(err.error?.message || `API error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.choices?.[0]?.message?.content?.trim();
  if (!content) return null;

  try {
    return JSON.parse(content);
  } catch (e) {
    // Fallback: treat as plain text (old format)
    return { narration: content, text_blocks: [], page_bounds: null };
  }
}

// --- TTS Providers ---
async function openaiTTS(text) {
  const speed = parseFloat(localStorage.getItem('speed') || '0.9');
  const voice = localStorage.getItem('voice') || 'fable';

  const response = await fetch('https://api.openai.com/v1/audio/speech', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model: 'tts-1',
      input: text,
      voice: voice,
      speed: speed,
      response_format: 'mp3'
    })
  });

  if (!response.ok) {
    const err = await response.json().catch(() => ({}));
    throw new Error(err.error?.message || `TTS error: ${response.status}`);
  }

  return response.arrayBuffer();
}

async function elevenLabsTTS(text) {
  const elApiKey = localStorage.getItem('elevenlabs_api_key');
  if (!elApiKey) throw new Error('ElevenLabs API key not set. Go to Settings.');

  const voiceId = localStorage.getItem('elevenlabs_voice') || 'pNInz6obpgDQGcFmaJgB';
  const stability = parseFloat(localStorage.getItem('elevenlabs_stability') || '0.3');

  const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'xi-api-key': elApiKey
    },
    body: JSON.stringify({
      text: text,
      model_id: 'eleven_multilingual_v2',
      voice_settings: {
        stability: stability,
        similarity_boost: 0.75,
        style: 0.8,
        use_speaker_boost: true
      }
    })
  });

  if (!response.ok) {
    const err = await response.json().catch(() => ({}));
    throw new Error(err.detail?.message || err.detail?.status || `ElevenLabs error: ${response.status}`);
  }

  return response.arrayBuffer();
}

// --- TTS Orchestration ---
async function speakNarration(text, textBlocks) {
  const provider = localStorage.getItem('tts_provider') || 'openai';

  let arrayBuffer;
  if (provider === 'elevenlabs') {
    arrayBuffer = await elevenLabsTTS(text);
  } else {
    arrayBuffer = await openaiTTS(text);
  }

  return new Promise((resolve, reject) => {
    audioCtx.decodeAudioData(arrayBuffer, (audioBuffer) => {
      // Store for replay
      lastAudioBuffer = audioBuffer;

      // Save page to book history (with image and text blocks)
      bookPages.push({ text, audioBuffer, imageDataUrl: lastImageDataUrl, textBlocks: textBlocks || [] });

      playAudioBuffer(audioBuffer, text, resolve, textBlocks);
    }, (err) => {
      reject(new Error('Audio decode failed'));
    });
  });
}

function playAudioBuffer(audioBuffer, text, onDone, textBlocks) {
  // Stop any currently playing audio
  if (currentAudio) {
    try { currentAudio.stop(); } catch(e) {}
    currentAudio = null;
  }
  clearHighlightTimers();

  const source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(audioCtx.destination);
  currentAudio = source;

  // Show highlights on captured image, or fallback to text overlay
  if (textBlocks && textBlocks.length > 0 && capturedImg.classList.contains('visible')) {
    createTextHighlights(textBlocks, audioBuffer.duration);
  } else if (text) {
    showNarration(text, audioBuffer.duration);
  }

  source.onended = () => {
    currentAudio = null;
    if (onDone) onDone();
  };

  source.start(0);
}

// --- Stop ---
function stopReading() {
  if (currentAudio) {
    try { currentAudio.stop(); } catch(e) {}
    currentAudio.onended = null;
    currentAudio = null;
  }
  isPlayingBook = false;
  clearHighlightTimers();
  hideStatus();
  isProcessing = false;
  showIdleUI();
  // Reset reading indicator label
  readingIndicator.querySelector('.label').textContent = 'Reading...';
}

// --- Repeat ---
function replayLastPage() {
  if (!lastAudioBuffer || !lastNarrationText || isProcessing) return;
  isProcessing = true;
  ensureAudioContext();
  // Show captured image for replay
  if (lastImageDataUrl) {
    showCapturedImage(lastImageDataUrl);
  }
  showReadingUI();
  playAudioBuffer(lastAudioBuffer, lastNarrationText, () => {
    isProcessing = false;
    showIdleUI();
  }, lastTextBlocks);
}

// --- Play Full Book ---
function playFullBook() {
  if (bookPages.length === 0 || isProcessing) return;
  isProcessing = true;
  isPlayingBook = true;
  bookPlaybackIndex = 0;
  ensureAudioContext();
  showReadingUI();
  playNextBookPage();
}

function playNextBookPage() {
  if (bookPlaybackIndex >= bookPages.length || !isPlayingBook) {
    isPlayingBook = false;
    isProcessing = false;
    showIdleUI();
    return;
  }

  const page = bookPages[bookPlaybackIndex];
  const label = readingIndicator.querySelector('.label');
  label.textContent = `Page ${bookPlaybackIndex + 1} of ${bookPages.length}`;

  // Show this page's captured image
  if (page.imageDataUrl) {
    showCapturedImage(page.imageDataUrl);
  }

  playAudioBuffer(page.audioBuffer, page.text, () => {
    bookPlaybackIndex++;
    setTimeout(() => playNextBookPage(), 800);
  }, page.textBlocks);
}

// --- Auto page detection ---
const autoToggle = $('#auto-toggle');
const compareCanvas = document.createElement('canvas');
const compareCtx = compareCanvas.getContext('2d', { willReadFrequently: true });
const COMPARE_SIZE = 128;
compareCanvas.width = COMPARE_SIZE;
compareCanvas.height = COMPARE_SIZE;

let referenceFrame = null; // Fixed reference ‚Äî only resets after a read
let pendingSettle = false; // Prevents multiple settle checks

function getFrameFingerprint() {
  if (!video.videoWidth) return null;
  compareCtx.drawImage(video, 0, 0, COMPARE_SIZE, COMPARE_SIZE);
  return compareCtx.getImageData(0, 0, COMPARE_SIZE, COMPARE_SIZE).data;
}

function computeDiff(a, b) {
  if (!a || !b || a.length !== b.length) return 100;
  let totalDiff = 0;
  const totalPixels = a.length / 4;
  for (let i = 0; i < a.length; i += 4) {
    const dr = Math.abs(a[i] - b[i]);
    const dg = Math.abs(a[i+1] - b[i+1]);
    const db = Math.abs(a[i+2] - b[i+2]);
    if (dr + dg + db > 40) totalDiff++;
  }
  return (totalDiff / totalPixels) * 100;
}

function startAutoDetect() {
  // Take initial reference snapshot
  referenceFrame = getFrameFingerprint();
  pendingSettle = false;

  autoDetectInterval = setInterval(() => {
    if (isProcessing || pendingSettle || Date.now() < cooldownUntil) return;

    const currentFrame = getFrameFingerprint();
    if (!currentFrame || !referenceFrame) {
      referenceFrame = currentFrame;
      return;
    }

    // Always compare against the FIXED reference, not the previous frame
    const diff = computeDiff(referenceFrame, currentFrame);

    if (diff > DIFF_THRESHOLD) {
      // Something changed! Now check if the camera is steady
      pendingSettle = true;
      const triggerFrame = currentFrame;
      setTimeout(() => {
        const settledFrame = getFrameFingerprint();
        // Compare two recent frames to check steadiness (not vs reference)
        const shakeDiff = computeDiff(triggerFrame, settledFrame);
        if (shakeDiff < 3 && !isProcessing) {
          // Camera is steady and content differs from reference ‚Äî read it
          processPage();
          // Reference will be reset in processPage finally block
        }
        pendingSettle = false;
      }, 500);
    }
    // NOTE: we do NOT update referenceFrame here ‚Äî it stays fixed
  }, CHECK_INTERVAL);
}

function resetAutoReference() {
  referenceFrame = getFrameFingerprint();
}

function stopAutoDetect() {
  if (autoDetectInterval) {
    clearInterval(autoDetectInterval);
    autoDetectInterval = null;
  }
  referenceFrame = null;
  pendingSettle = false;
}

function toggleAutoMode() {
  autoMode = !autoMode;
  autoToggle.classList.toggle('active', autoMode);

  if (autoMode) {
    hintEl.textContent = 'Auto mode: turn the page!';
    startAutoDetect();
  } else {
    hintEl.textContent = 'Point at a book page, then tap!';
    stopAutoDetect();
  }
}

// --- Event listeners ---
captureBtn.addEventListener('click', processPage);
repeatBtn.addEventListener('click', replayLastPage);
playBookBtn.addEventListener('click', playFullBook);
stopBtn.addEventListener('click', stopReading);
autoToggle.addEventListener('click', () => {
  // First tap also unlocks audio for auto mode
  ensureAudioContext();
  toggleAutoMode();
});

// TTS provider toggle
function updateTTSProviderUI() {
  const provider = $('#tts-provider').value;
  const elSettings = $('#elevenlabs-settings');
  const openaiVoice = $('#voice').closest('.setting-group');
  if (provider === 'elevenlabs') {
    elSettings.style.display = '';
    openaiVoice.style.display = 'none';
  } else {
    elSettings.style.display = 'none';
    openaiVoice.style.display = '';
  }
}
$('#tts-provider').addEventListener('change', updateTTSProviderUI);

// Settings
$('#settings-btn').addEventListener('click', () => {
  $('#settings-api-key').value = apiKey;
  updateTTSProviderUI();
  settingsPanel.classList.add('visible');
});

$('#close-settings').addEventListener('click', () => {
  settingsPanel.classList.remove('visible');
});

$('#save-api-key').addEventListener('click', () => {
  const newKey = $('#settings-api-key').value.trim();
  if (newKey) {
    apiKey = newKey;
    localStorage.setItem('openai_api_key', apiKey);
  }
  localStorage.setItem('speed', $('#speed').value);
  localStorage.setItem('response_lang', $('#response-lang').value);
  localStorage.setItem('voice', $('#voice').value);
  localStorage.setItem('tts_provider', $('#tts-provider').value);
  const elKey = $('#elevenlabs-api-key').value.trim();
  if (elKey) localStorage.setItem('elevenlabs_api_key', elKey);
  localStorage.setItem('elevenlabs_voice', $('#elevenlabs-voice').value);
  localStorage.setItem('elevenlabs_stability', $('#elevenlabs-stability').value);
  settingsPanel.classList.remove('visible');
});

// Initial API key
$('#submit-api-key').addEventListener('click', () => {
  const key = $('#initial-api-key').value.trim();
  if (!key) return;
  ensureAudioContext(); // Unlock audio on this user tap
  apiKey = key;
  localStorage.setItem('openai_api_key', apiKey);
  apiKeyOverlay.classList.add('hidden');
  startCamera();
});

// Allow Enter key on API key input
$('#initial-api-key').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') $('#submit-api-key').click();
});

init();
</script>
</body>
</html>
